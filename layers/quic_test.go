// Copyright 2012 Google, Inc. All rights reserved.
// Copyright 2009-2011 Andreas Krennmair. All rights reserved.
// Copyright 2017 Brian Trammell. All Rights Reserved.
//
// Use of this source code is governed by a BSD-style license
// that can be found in the LICENSE file in the root of the source
// tree.

package layers

import (
	"testing"

	"github.com/google/gopacket"
)

// Vector of test expectations
var test_expected = []struct {
	PktType    byte
	ConnID     uint64
	HasConnID  bool
	PktNum     uint32
	PktNumLen  int
	Version    uint32
	HasVersion bool
	KeyPhase   int
}{
	{QUICPktTypeVersionNego, 0xc0ffeec0ffee600d, true, 0xfedcba98, 4, 0xff000004, true, 0},
	{QUICPktTypeStatelessReset, 0xbadbadbadbadbad1, true, 0xbadbad22, 4, 0xff000004, true, 0},
	{QUICPktTypeShortP0P1, 0, false, 0x42, 1, 0, false, 0},
	{QUICPktTypeShortP1P2, 0, false, 0x4242, 2, 0, false, 1},
	{QUICPktTypeShortP1P4, 0, false, 0x42424242, 4, 0, false, 1},
	{QUICPktTypeShortCidP1P4, 0xc0ffeec0ffee600d, true, 0x42424242, 4, 0, false, 1},
}

// Vector of synthetic test packets
var test_packets = [][]byte{
	// version_negotiation
	{
		0x7e, 0x57, 0x7e, 0x11, 0x11, 0x11, 0x7e, 0x57, 0x7e, 0x0, 0x0, 0x0,
		0x8, 0x0, 0x45, 0x0, 0x0, 0x35, 0x0, 0x1, 0x0, 0x0, 0x40, 0x11, 0x4b,
		0x82, 0xa, 0xb, 0xc, 0xd, 0xa, 0xe, 0xf, 0x10, 0xdd, 0xc8, 0x1, 0xbb,
		0x0, 0x21, 0xde, 0xf6, 0x81, 0xc0, 0xff, 0xee, 0xc0, 0xff, 0xee, 0x60,
		0xd, 0xfe, 0xdc, 0xba, 0x98, 0xff, 0x0, 0x0, 0x4, 0xff, 0x0, 0x0, 0x4,
		0x1a, 0x2a, 0x1a, 0x2a,
	},

	// stateless_reset
	{
		0x7e, 0x57, 0x7e, 0x0, 0x0, 0x0, 0x7e, 0x57, 0x7e,
		0x11, 0x11, 0x11, 0x8, 0x0, 0x45, 0x0, 0x0, 0x2d, 0x0, 0x1, 0x0, 0x0, 0x40,
		0x11, 0x4b, 0x8a, 0xa, 0xe, 0xf, 0x10, 0xa, 0xb, 0xc, 0xd, 0x1, 0xbb, 0xdd,
		0xc8, 0x0, 0x19, 0x4e, 0x9c, 0x89, 0xba, 0xdb, 0xad, 0xba, 0xdb, 0xad, 0xba,
		0xd1, 0xba, 0xdb, 0xad, 0x22, 0xff, 0x0, 0x0, 0x4,
	},

	// short1
	{
		0x7e, 0x57, 0x7e, 0x11, 0x11, 0x11, 0x7e, 0x57, 0x7e, 0x0, 0x0, 0x0,
		0x8, 0x0, 0x45, 0x0, 0x0, 0x35, 0x0, 0x1, 0x0, 0x0, 0x40, 0x11, 0x4b,
		0x82, 0xa, 0xb, 0xc, 0xd, 0xa, 0xe, 0xf, 0x10, 0xdd, 0xc8, 0x1, 0xbb,
		0x0, 0x21, 0xed, 0xf3, 0x1, 0x42, 0x64, 0x6f, 0x6e, 0x74, 0x6c, 0x6f,
		0x6f, 0x6b, 0x61, 0x74, 0x6d, 0x65, 0x69, 0x6d, 0x65, 0x6e, 0x63, 0x72,
		0x79, 0x70, 0x74, 0x65, 0x64,
	},

	// short2
	{
		0x7e, 0x57, 0x7e, 0x11, 0x11, 0x11, 0x7e, 0x57, 0x7e, 0x0, 0x0, 0x0,
		0x8, 0x0, 0x45, 0x0, 0x0, 0x36, 0x0, 0x1, 0x0, 0x0, 0x40, 0x11, 0x4b,
		0x81, 0xa, 0xb, 0xc, 0xd, 0xa, 0xe, 0xf, 0x10, 0xdd, 0xc8, 0x1, 0xbb,
		0x0, 0x22, 0xcf, 0xac, 0x22, 0x42, 0x42, 0x64, 0x6f, 0x6e, 0x74, 0x6c,
		0x6f, 0x6f, 0x6b, 0x61, 0x74, 0x6d, 0x65, 0x69, 0x6d, 0x65, 0x6e, 0x63,
		0x72, 0x79, 0x70, 0x74, 0x65, 0x64,
	},

	// short4
	{
		0x7e, 0x57, 0x7e, 0x11, 0x11, 0x11, 0x7e, 0x57, 0x7e, 0x0, 0x0, 0x0,
		0x8, 0x0, 0x45, 0x0, 0x0, 0x38, 0x0, 0x1, 0x0, 0x0, 0x40, 0x11, 0x4b,
		0x7f, 0xa, 0xb, 0xc, 0xd, 0xa, 0xe, 0xf, 0x10, 0xdd, 0xc8, 0x1, 0xbb,
		0x0, 0x24, 0x8c, 0x66, 0x23, 0x42, 0x42, 0x42, 0x42, 0x64, 0x6f, 0x6e,
		0x74, 0x6c, 0x6f, 0x6f, 0x6b, 0x61, 0x74, 0x6d, 0x65, 0x69, 0x6d, 0x65,
		0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x65, 0x64,
	},

	// shortcid
	{
		0x7e, 0x57, 0x7e, 0x11, 0x11, 0x11, 0x7e, 0x57, 0x7e, 0x0, 0x0, 0x0,
		0x8, 0x0, 0x45, 0x0, 0x0, 0x40, 0x0, 0x1, 0x0, 0x0, 0x40, 0x11, 0x4b,
		0x77, 0xa, 0xb, 0xc, 0xd, 0xa, 0xe, 0xf, 0x10, 0xdd, 0xc8, 0x1, 0xbb,
		0x0, 0x2c, 0x8f, 0x46, 0x63, 0xc0, 0xff, 0xee, 0xc0, 0xff, 0xee, 0x60,
		0xd, 0x42, 0x42, 0x42, 0x42, 0x64, 0x6f, 0x6e, 0x74, 0x6c, 0x6f, 0x6f,
		0x6b, 0x61, 0x74, 0x6d, 0x65, 0x69, 0x6d, 0x65, 0x6e, 0x63, 0x72, 0x79,
		0x70, 0x74, 0x65, 0x64,
	},
}

func TestQUICDecoder(t *testing.T) {
	for i, pv := range test_packets {
		exp := test_expected[i]
		p := gopacket.NewPacket(pv, LinkTypeEthernet, gopacket.Default)

		if p.ErrorLayer() != nil {
			t.Error("Failed to decode packet:", p.ErrorLayer().Error())
		}

		checkLayers(p,
			[]gopacket.LayerType{LayerTypeEthernet,
				LayerTypeIPv4,
				LayerTypeUDP,
				LayerTypeQUIC},
			t)

		if got, ok := p.ApplicationLayer().(*QUIC); ok {

			if exp.PktType != got.PktType {
				t.Errorf("Packet %d: Expected packet type %x got %x", i, exp.PktType, got.PktType)
			}

			if exp.HasConnID != got.HasConnID {
				t.Errorf("Packet %d: Surprise! Connection ID!", i)
			}

			if exp.HasVersion != got.HasVersion {
				t.Errorf("Packet %d: Surprise! Version!", i)
			}

			if exp.HasConnID && (exp.ConnID != got.ConnID) {
				t.Errorf("Packet %d: Expected Connection ID %x got %x", i, exp.ConnID, got.ConnID)
			}

			if exp.HasVersion && (exp.Version != got.Version) {
				t.Errorf("Packet %d: Expected Version %x got %x", i, exp.Version, got.Version)
			}
		} else {
			t.Errorf("Packet %d: Application layer packet not QUIC", i)
		}
	}
}
